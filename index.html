<!doctype html>

<html>
  <head>
<meta name = "viewport" content = "initial-scale = 1.0">
<style>
  * {
    font-family: Courier;
    margin: 0; paddig: 0;
  }
  .cursor {
    background-color: lightblue;
  }
</style>
<script src="underscore-min.js"></script>
<script src="zepto.min.js"></script>
</head>
<body style="height:1200px;">
  <div id="w">
  </div>
  <div id="k">
    <br />
    <div id="notes"></div>
  </div>
</body>
<script id="s">//stuff
  setTimeout(function () { window.scrollTo(0, 1) }, 100)

  var mode = "scroll"
  var line  = []
  var lines = [line]
  var y_index = 0
  var x_index = 0
  var x_offset = 0
  var y_offset = 0
  var viewport_width = 320
  var x_viewport = 16

  var viewport_height = 360
  var y_viewport = 10
  var chr_width = (viewport_width / x_viewport)
  var chr_height = (viewport_height / y_viewport)

  font_size = 35
  w = $("#w")
  w.css({"width": viewport_width + "px", "height": viewport_height + "px"})
  notes = $("#notes")
  var cells = []
  var setup_screen = function () {
    cells = []
    for (var y = 0; y < y_viewport; y++) {
      for (var x = 0; x < x_viewport; x++) {
        var chr = $("<div>");
        chr.css({
          "left": x*chr_width,
          "top": y*chr_height,
          "position": "absolute",
          "width":  chr_width + "px",
          "height":  chr_height + "px",
          "font-size":  font_size + "px",
          "text-align": "center"
        })
        chr.attr("id", "c" + x + "_" + y)
        cells.push(chr)
        chr.text("a")
        w.append(chr)
      } 
    }
  }

  var clear = function () {
    $(".cursor").removeClass("cursor") //is this slow?
    for (var y = 0; y < y_viewport; y++) {
      for (var x = 0; x < x_viewport; x++) {
        var cell = cells[x_viewport * y + x]
        cell.text("")
      }
    }
  }

  var render = function (x_offset, y_offset) {
    // todo: can optimize this to know when it should change
    if (mode == "scroll") {
      w.css("background-color", "lightyellow")
    } else {
      w.css("background-color", "white")
    }
    notes.text(x_offset + " " + y_offset)
    clear()
    // todo: can optinize this
    $("#c" + (-x_offset + x_index) + "_" + (-y_offset + y_index)).addClass("cursor");
    var c_line
    for (var y = y_offset; y < y_offset + y_viewport; y++) {
      c_line = lines[y];
      if (!c_line) continue;
      for (var x = x_offset; x < x_offset + x_viewport; x++) {
        var c_chr = c_line[x];
        var cell = cells[x_viewport * (y - y_offset) + (x - x_offset)]
        cell.text(c_chr)
      }
    }
  }

  var text_to_lines = function (text) {
    var lines = text.split("\n");
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      lines[i] = line.split("");
    }
    return lines
  }
  setup_screen();
  var log_index = 0
  var l = function(m){
    log_index += 1
    document.title = 
      log_index + " " + m
  }

  var touch = {}
     
  //https://github.com/drewlesueur/mobile/blob/server/public/index.js

  var move_factor = function (z) {
    return -1 * parseInt(z / 10) 
  }
  
  var last_quadrant = null;

  var quadrant_map = {
    lefttop: "a",
    leftmiddle: "c",
    leftbottom: "e",
    righttop: "b",
    rightmiddle: "d",
    rightbottom: "f",
  }

  var get_quadrant = function (x, y) {
    // ab
    // cd
    // ef
    var x_full = viewport_width
    var x_one_half = x_full / 2

    var y_full = viewport_height
    var y_one_third = y_full / 3
    var y_two_thirds = y_one_third * 2
    var x_place;
    var y_place;

    if (x < x_one_half)  x_place = "left";
    else x_place = "right";

    if (y < y_one_third)  y_place = "top";
    else if (y < y_two_thirds)  y_place = "middle";
    else y_place = "bottom";
    return quadrant_map[x_place + y_place]
  }

  var quadrant_path = []
  
  var scroll_mode_timeout = null;
  var touchstart = function (e) {
    e.preventDefault()
    touch.y1 = e.touches[0].pageY
    touch.x1 = e.touches[0].pageX
    touch.y2 = touch.y1
    touch.x2 = touch.x1
    touch.pageX = e.touches[0].pageX
    touch.pageY = e.touches[0].pageY
    touch.start = Date.now()

    if (mode == "letters") {
      scroll_mode_timeout = setTimeout(function () {
        mode = "scroll"
        prevent_touchend = true
        render(move_factor(x_offset), move_factor(y_offset))   
      }, 200)
    }
  }

  var all_letters = [
    "abcdefghijklmnopqrstuvwzyz ",
    "0123456789",
    ",./<>?", "[]\\{}|;':\"",
    "!@#$%^&*()_+",
  ]
  var get_letter = function (x, y) {

    var x_percent = (x / viewport_width)
    var y_percent = (y / viewport_height)

   var column_index = parseInt(x_percent * all_letters.length)
   var column = all_letters[column_index]
   var letter_index = parseInt(y_percent * column.length)
   var letter = column[letter_index]
    return letter 
  }

  var temping_a_letter = 0
  var touchmove = function  (e) {
    clearTimeout(scroll_mode_timeout)
    touch.y2 = e.touches[0].pageY
    touch.x2 = e.touches[0].pageX
    if (mode == "scroll") {
      var temp_x_offset = (x_offset + touch.x2 - touch.x1)
      var temp_y_offset = (y_offset + touch.y2 - touch.y1)
      render(move_factor(temp_x_offset), move_factor(temp_y_offset))   
    } else if (mode == "letters") {
      var tmp_letter = get_letter(e.touches[0].pageX, e.touches[0].pageY); 
      if (tmp_letter == "backspace") {
        lines[y_index].splice(x_index - 1,1)
        x_index -= 1
      } else {
        lines[y_index].splice(x_index, temping_a_letter, tmp_letter)
        temping_a_letter = 1
      }
      render(move_factor(x_offset), move_factor(y_offset))   

      //var quadrant = get_quadrant(e.touches[0].pageX, e.touches[0].pageY); 
      //notes.text(quadrant)
      //if (quadrant != last_quadrant) {
      //  quadrant_path.push(quadrant) 
      //}
      //last_quadrant = quadrant;
    }

    e.preventDefault()
  }

  var letter_map = {
    bacefdbdf: "a",
    bdcefdbdf: "a",
    acecdfe: "b",
    cecdfe: "b",
    bacef: "c",
    dcefdbdf: "d",
    cdcef: "e",
    cdbacef: "e",
    bace: "f",
    bacdbdfe: "g",
    acecdf: "h",
    ce: "i",
    df: "i",
    bdfe: "j",
    dfe: "j",
    bdcdf: "k",
    bdcef: "k",
    ace: "l",
    bdf: "l",
    cecefdf: "m",
    cecfdf: "m",
    ecacfdbdf: "m",
    cecdf: "n",
    acefdb: "o",
    acefdbac: "o",
    bdfecab: "o",
    bacefdba: "o",
    acecadbc: "p",
    bacdbdf: "q",
    cecd: "r",
    bacdfe: "s",
    dcefe: "s",
    abdf: "t",
    cdf: "t",
    cefdf: "u",
    cefd: "v",
    cefdfd: "w",
    cef: "x",
    acdbdfe: "y",
    abdef: "z",
    abdef: "z",
    efef: "z",
    cdfef: "z",
    abcdef: "z",
    ef: " ",
    cbdf: "1",
    abdfef: "2",
    fe: "backspace"

  }
  var input_letter = function (quadrant_path) {
    var path = quadrant_path.join("")
    notes.text(path) 
    letter = letter_map[path]
    if (!letter) return;
    if (letter == "backspace") {
      lines[y_index].splice(x_index - 1,1)
      x_index -= 1
    } else {
      lines[y_index].splice(x_index, 0, letter)
      x_index += 1
    }
    render(move_factor(x_offset), move_factor(y_offset))   
  }
  var prevent_touchend = false
  var touchend = function (e) {
    temping_a_letter = 0
    clearTimeout(scroll_mode_timeout)
    if (prevent_touchend) {
      prevent_touchend = false 
      return
    }
    if (mode == "scroll") {
      x_offset = (x_offset + touch.x2 - touch.x1)
      y_offset = (y_offset + touch.y2 - touch.y1)
      if (touch.y2 == touch.y1 && touch.x2 == touch.x1) {
        mode = "letters"
        render(move_factor(x_offset), move_factor(y_offset))   
      }
    } else if (mode == "letters") {
       
      if (touch.y2 == touch.y1 && touch.x2 == touch.x1) {
        y_index = move_factor(y_offset) + parseInt(touch.pageY / chr_height)
        x_index = move_factor(x_offset) + parseInt(touch.pageX / chr_width)
        
       if (y_index >= lines.length) {
         y_index = lines.length - 1
       }

       if (x_index > lines[y_index].length) {
         x_index = lines[y_index].length
       }
        render(move_factor(x_offset), move_factor(y_offset))   
      } else {
        //input_letter(quadrant_path) 
        x_index += 1
        render(move_factor(x_offset), move_factor(y_offset))   
      }
      //quadrant_path = []
    }
  } 

  $(document).ready(function () {
    w.bind("touchstart", touchstart)
    w.bind("touchmove", touchmove)
    w.bind("touchend", touchend)
  })



  //var code = $("#s").html()
  //var code = "yo world\ntesting some code\nshould be able to scroll"; 
  var code = "hi"
  lines = text_to_lines(code)
  render(0, 0)
</script>
</html>

