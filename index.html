<!doctype html>

<html>
  <head>
<meta name = "viewport" content = "initial-scale = 1.0">
<style>
  * {
    font-family: Courier;
    margin: 0; paddig: 0;
  }
  .cursor {
    background-color: lightblue;
  }

</style>
<script src="underscore-min.js"></script>
<script src="zepto.min.js"></script>
</head>
<body style="height:1200px;">
  <canvas id="c"></canvas>
</body>
<script id="s">//stuff

  //setTimeout(function () { window.scrollTo(0, 1) }, 100)

  var screen_width = 320
  var screen_height = window.innerHeight

  var mode = "scroll"
  var line  = []
  var lines = [line]
  var y_cursor = 0
  var x_cursor = 0
  var x_offset = 0
  var y_offset = 0
  var viewport_width = 320
  var x_viewport = 16

  var viewport_height = 360

  var y_viewport = 10
  var chr_width = (viewport_width / x_viewport)
  var chr_height = (viewport_height / y_viewport)

  var font_size = 35
  var font_name = "Courier"

  var insert_mode_timeout = null
  var c = $("#c")
  var canvas_width = screen_width
  var canvas_height = screen_height
  c.css({
    width: canvas_width + "px",
    height: canvas_height + "px" ,
    position: "absolute",
    left: 0,
    "top": 0
  })
  c.attr("width", canvas_width * 2)
  c.attr("height", canvas_height * 2)
  var ctx = c[0].getContext("2d")
  ctx.scale(2,2)
  ctx.textBaseline = "top"
  ctx.font = font_size + "px " + font_name

  var tick = function () {
     
  }

  webkitRequestAnimationFrame(tick)


  var clear_viewport = function () {
    ctx.clearRect(0,0, viewport_width, viewport_height)
  }

  var render = function () {
    render_raw(x_offset, y_offset)
    // # todo maybe cache the result of the move_factor call
  }

  var draw_cursor = function (x_offset, y_offset) {
    var x = (x_offset + chr_width * x_cursor)
    var y = (y_offset + chr_height * y_cursor)
    ctx.save()
    ctx.fillStyle = "rgba(0,0,255, 0.5)"
    ctx.fillRect(x,y, chr_width, chr_height)
    ctx.restore()
  }

  var draw_text = function (x_offset, y_offset) {
    var c_line
    var y_start = Math.floor(-y_offset / chr_height)
    var x_start = Math.floor(-x_offset / chr_width)
    // todo maybe cache y_start
    var x_px
    var y_px
   
    for (var y = y_start; y < y_start + y_viewport + 1; y++) {
      c_line = lines[y];
      y_px = (y_offset + chr_height * y)
      if (!c_line) continue;
      for (var x = x_start; x < x_start + x_viewport + 1; x++) {
        var c_chr = c_line[x];
        x_px = (x_offset + chr_width * x)
        if (c_chr) {
          ctx.fillText(c_chr, x_px, y_px)
        }
      }
    }
    
  }

  var render_raw = function (x_offset, y_offset) {
    // todo: can optimize this to know when it should change
    clear_viewport()

    ctx.save()
    if (mode == "scroll") {
      ctx.fillStyle = "rgba(255, 255, 0, 0.1)";
    } else {
      ctx.fillStyle = "rgba(0, 255, 0, 0.1)";
    }
    ctx.fillRect(0,0,screen_width, screen_height)
    ctx.restore()

    draw_cursor(x_offset, y_offset)
    draw_text(x_offset, y_offset)
    var c_line
    //for (var y = y_offset; y < y_offset + y_viewport; y++) {
    //  c_line = lines[y];
    //  if (!c_line) continue;
    //  for (var x = x_offset; x < x_offset + x_viewport; x++) {
    //    var c_chr = c_line[x];
    //    var cell = cells[x_viewport * (y - y_offset) + (x - x_offset)]
    //    cell.text(c_chr)
    //  }
    //}
  }

  var text_to_lines = function (text) {
    var lines = text.split("\n");
    for (var i = 0; i < lines.length; i++) {
      var line = lines[i];
      lines[i] = line.split("");
    }
    return lines
  }

  var log_index = 0
  var l = function(m){
    log_index += 1
    document.title = 
      log_index + " " + m
  }

  var touch = {}
     
  //https://github.com/drewlesueur/mobile/blob/server/public/index.js
  var move_factor = function (z) {
    return -1 * parseInt(z / 10) 
  }
  
  var mouse = "up"
  var finger = "up"
  auto_mouseup = false
  setTimeout(function () {
    var auto_mouseup = true
  }, 1000)


  var mousedown = function (e) {
    touchstart({ preventDefault: function () {}, touches: [{pageX: e.pageX, pageY: e.pageY}]})
    mouse = "down"
  }

  var mousemove = function (e) {
    if (mouse == "up") return
    touchmove({ preventDefault: function () {}, touches: [{pageX: e.pageX, pageY: e.pageY}]})

    if (auto_mouseup) {
      auto_mouseup = false
      mouseup()
    }
  }

  var mouseup = function () {
    mouse = "up"
    touchend()
  }
  
  var enter_insert_mode = function () {
    mode = "insert"
    render()
  }

  var backspace_timeout
  var touchstart = function (e) {
    finger = "down"
    e.preventDefault()
    touch.y1 = e.touches[0].pageY
    touch.x1 = e.touches[0].pageX
    touch.y2 = touch.y1
    touch.x2 = touch.x1
    touch.old_y2 = touch.y1
    touch.old_x2 = touch.x1
    touch.pageX = e.touches[0].pageX
    touch.pageY = e.touches[0].pageY
    touch.start = Date.now()
    touch.side = touch.x1 < viewport_width / 2 ? "." : "-"
    if (mode == "scroll") {
      insert_mode_timeout = setTimeout(function () {
        prevent_insert = true
        enter_insert_mode()
      }, 200)
    } else {
      //backspace_timeout = setTimeout(function () {
      //  mode = "backspace"
      //  backspace_interval = setInterval(backspace, 200) 
      //}, dot_length * 4)

      console.log("douch down " + touch.side )
      codes.push(touch.side)
    }

  }

  var angle_diff = function (theta, beta) {
    var diff = Math.abs(theta - beta)
    if (diff > Math.PI) {
      if (theta > beta) {
        return 2 * Math.PI - theta + beta
      } else {
        return 2 * Math.PI - beta + theta
      }
    } else {
      return diff
    }
  }

  var angle_counter = 0
  var touchmove = function  (e) {
    clearTimeout(insert_mode_timeout)
    touch.old_y2 = touch.y2
    touch.old_x2 = touch.x2

    touch.y2 = e.touches[0].pageY
    touch.x2 = e.touches[0].pageX

    if (mode == "scroll") {
      var temp_x_offset = (x_offset + touch.x2 - touch.x1)
      var temp_y_offset = (y_offset + touch.y2 - touch.y1)
      render_raw(temp_x_offset, temp_y_offset)   
    } else if (mode == "insert") {
      var side = touch.x2 < viewport_width / 2 ? "." : "-"
      if (side != touch.side) {
        console.log("added because of new side " + side)
        codes.push(side)
        touch.side = side
      }
       
        var y_diff = (touch.y2 - touch.y1)
        var x_diff = (touch.x2 - touch.x1)
        var angle = Math.atan(y_diff / x_diff)
        var distance = Math.pow(Math.pow(touch.y2 - touch.y1, 2) + Math.pow(touch.x2 - touch.x1, 2), 0.5)
        if (y_diff >= 0 && x_diff < 0) {
          angle = Math.PI + -angle
        } else if (y_diff < 0 && x_diff >= 0) {
          angle = -angle
        } else if (y_diff < 0 && x_diff < 0) {
          angle = (Math.PI - angle)
        } else if (y_diff >= 0 && x_diff >= 0) {
          angle = (Math.PI - angle) + Math.PI
        } else {
          angle = 0 
        }


        // if (isNaN(angle)) debugger

        console.log(angle / Math.PI * 180, distance)
        return

        if (touch.angle && angle_diff(angle, touch.angle) > Math.PI / 6) {
         // console.log(angle, touch.angle)
         // console.log(angle / Math.PI * 180)
         // console.log("added direction " + side)
          codes.push(side)
          console.log(codes.join(""))
        } else {
           
        }

        touch.angle = angle


      return
      render()   
    }

    e.preventDefault()
  }

  var input_letter = function (quadrant_path) {
    var path = quadrant_path.join("")
    notes.text(path) 
    letter = letter_map[path]
    if (!letter) return;
    if (letter == "backspace") {
      lines[y_cursor].splice(x_cursor - 1,1)
      x_cursor -= 1
    } else {
      lines[y_cursor].splice(x_cursor, 0, letter)
      x_cursor += 1
    }
    render()   
  }

  var touch_time
  var touchend = function (e) {
    finger = "up"
    clearTimeout(insert_mode_timeout)
    clearInterval(backspace_interval)
    clearTimeout(backspace_timeout)
    if (mode == "backspace") {
      mode = "insert"
    } else if (mode == "scroll") {
      x_offset = (x_offset + touch.x2 - touch.x1)
      y_offset = (y_offset + touch.y2 - touch.y1)
      if (touch.y2 == touch.y1 && touch.x2 == touch.x1) {
        y_cursor = Math.floor((touch.pageY - y_offset)/ chr_height)
        x_cursor = Math.floor((touch.pageX - x_offset)/ chr_width)
        
       if (y_cursor >= lines.length) {
         y_cursor = lines.length - 1;
       } else if (y_cursor < 0) {
        y_cursor = 0
       }


       if (x_cursor > lines[y_cursor].length) {
         x_cursor = lines[y_cursor].length;
       } else if (x_cursor < 0) {
         x_cursor = 0 
       }
       render()   
      }
    } else if (mode == "insert") {
      if (prevent_insert) {
        prevent_insert = false
        return
      }
      codes.push(touch.side)
      touch_time = Date.now() - touch.start
      add_morse_letter()
    }
  } 
  var backspace_interval;
  var prevent_insert = false
  var add_morse_letter_timeout;
  var add_morse_word_timeout;
  var add_morse_word = function () {
   // while (letter_queue.length) {
     // add_letter(letter_queue.shift())
    //}
    add_letter(" ")
    render()
  }
  
  letter_queue = []
  var add_letter = function (letter) {
    lines[y_cursor].splice(x_cursor, 0, letter)
    x_cursor += 1
    if (x_cursor > x_viewport) {
      
    }
    render()
  }

  var backspace = function () {
    console.log("backspace")
    lines[y_cursor].splice(x_cursor - 1,1)
    x_cursor -= 1
    render()
  }
  var add_morse_letter = function () {
    if (finger == "down") return;
    console.log(codes.join(""))
    var letter = morse_codes[codes.join("")]
    console.log(letter)
    codes = []
    //document.title = letter
    if (letter == "backspace") {
      return backspace()
    } else if (letter == "AR") {
      mode = "scroll"
      render()
    } else if (letter == "newline") {
      lines.splice(y_cursor + 1, 0, lines[y_cursor].splice(x_cursor))
      y_cursor += 1
      x_cursor = 0
    } else {
      add_letter(letter)
      //letter_queue.push(letter)
    }
    //render()   
  } 

  var dot_length = 150
  var letter_spacing = dot_length * 3 
  var word_spacing = dot_length * 7 
  var codes = []
  var morse_codes = {
    ".-.-" : "newline",
    ".-.-.": "AR",
    "......": "backspace",
    ".-": "a",
    "_...": "b",
    "-.-.": "c",
    "-..": "d",
    ".": "e",
    "..-.": "f",
    "--.": "g",
    "....": "h",
    "..": "i",
    ".---": "j",
    "-.-": "k",
    ".-..": "l",
    "--": "m",
    "-.": "n",
    "---": "o",
    ".--.": "p",
    "--.-": "q",
    ".-.": "r",
    "...": "s",
    "-": "t",
    "..-": "u",
    "...-": "v",
    ".--": "w",
    "-..-": "x",
    "-.--": "y",
    "--..": "z"
  }

  $(document).ready(function () {
    if (screen.width > 320) {
      $(document.body).bind("mousedown", mousedown)
      $(document.body).bind("mousemove", mousemove)
      $(document.body).bind("mouseup", mouseup)
    
    } else {
      $(document.body).bind("touchstart", touchstart)
      $(document.body).bind("touchmove", touchmove)
      $(document.body).bind("touchend", touchend)
    
    }
  })



  var code = "one\ntwo\nthree\nfour\nfive"
  lines = text_to_lines(code)
  render()
</script>
</html>

